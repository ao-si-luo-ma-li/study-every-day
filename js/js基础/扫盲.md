### 1、JavaScript 逗号表达式
```
逗号表达式的一般形式是：表达式1，表达式2，表达式3……表达式n 
逗号表达式的求解过程是：先计算表达式1的值，再计算表达式2的值，……一直计算到表达式n的值。最后整个逗号表达式的值是表达式n的值
```

### 2、for…in 循环
* for…in循环会遍历数组对象的原型链中所有的可枚举属性（可以使用<b><font color=red>hasOwnProperty()</font></b>方法判断是否为对象自身属性，而非原型链中属性）
* 循环除了访问数组元素以外，还会访问其它的可遍历属性

### 3、new Object和Object.create到底干了啥
* new XXX()时发生了什么?
  ```
    var obj={};
    obj.__proto__=Car.prototype
    Car.call(obj)
  ```
  第一步，创建了一个空对象obj；
  第二步，将空对象的__proto__成员指向了Car函数的原型属性，该原型属性是一个原型对象，也就意味着obj的原型属性上拥有了Car.prototype中的属性或方法；
  第三步，将Car函数中的this指针指向obj，obj有了Car构造函数中的属性或方法 ，然后Car函数无返回值或返回的不是对象，直接返回obj，否则返回Car函数中的对象

+ Object.create时发生了什么？
  <font color=red>语法：Object.create(proto[, propertiesObject])</font>
  proto: 新创建对象的原型对象;
  propertiesObject: 
  + 1. Object.create(o),如果o是一个构造函数，则采用这种方法来创建对像没有意义
  + 2. Object.create(o),如果o是一个字面量对象或实例对象，那么相当于是实现了对象的浅拷贝。并且新创建对象的__proto__指向现有的对象


### 4、parseInt 详解
> parseInt 函数将其第一个参数转换为字符串，解析它，并返回一个整数或NaN。如果不是NaN，返回的值将是作为指定基数（基数）中的数字的第一个参数的整数。

<font size=5>parseInt(string, radix)。</font>
string 要被解析的值，如果不是字符串，则将其转化为字符串（使用toString抽象操作）。
radix 一个介于2和36之间的整数，表示上述字符串的基数

<font color=red>扩展：引用对象也能转字符串；</font>


返回值：返回解析后的整数值。 如果parseInt的字符不是指定基数中的数字，则忽略该字符和所有后续字符，并返回解析到该点的整数值。parseInt将数字截断为整数值。如果被解析参数的第一个字符无法被转化成数值类型，则返回 NaN。

### 5、JS中类型转换有哪几种？
JS中，类型转换只有三种：
* 转换成数字
* 转换成布尔值
* 转换成字符串

<img src="https://user-gold-cdn.xitu.io/2019/10/20/16de9512eaf1158a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">

扩展知识点：
* 1、使用 == 运算符时涉及了哪些隐式类型转换？
  + 两边的类型是否相同，相同的话就比较值的大小，例如1==2，返回false
  + 判断的是否是null和undefined，是的话就返回true
  + 判断的类型是否是String和Number，是的话，把String类型转换成Number，再进行比较
  + 判断其中一方是否是Boolean，是的话就把Boolean转换成Number，再进行比较
  + 如果其中一方为Object，且另一方为String、Number或者Symbol，会将Object转换成字符串，再进行比较
  ```
  例：
    console.log({a: 1} == true);  // false
    console.log({a: 1} == "[object Object]");  // true
  ```
* 2、对象转原始类型是根据什么流程运行的？
  <font color=red>对象转原始类型，会调用内置的[Symbol.toPrimitive]函数，对于该函数而言，其逻辑如下：</font>
  + 1、如果Symbol.toPrimitive()方法，优先调用再返回
  + 2、调用valueOf()，如果转换为原始类型，则返回
  + 3、调用toString()，如果转换为原始类型，则返回
  + 4、如果都没有返回原始类型，会报错
  ```
  例：
    var obj = {
      value: 6,
      valueOf() {
        return 5
      },
      toString() {
        return '4'
      },
      [Symbol.toPrimitive]() {
        return 99
      }
    }
    console.log(obj + 1)   // 100
  ```
### 6、订阅发布模式
```
const EventEmitter = {
  events: {},
  // 订阅
  on: function(eventName, cb, once=false) {
    if (typeof cb !== 'function') {
      throw new Error('cb 不是一个函数！');
    }
    !this.events[eventName] && (this.events[eventName] = []);
    this.events[eventName].push({fn: cb, once});
  },
  // 触发
  emit: function(eventName, ...args) {
    const cblist = this.events[eventName];
    // 找到已订阅的事件
    if (cblist) {
      for (let index = 0; index < cblist.length; index++) {
        cblist[index].fn(...args);
        if (cblist[index].once) {
          cblist.splice(index, 1);
        }
      }
    }
  },
  // 清除订阅
  off: function(eventName, removeCb) {
    if (eventName && this.events[eventName]) {
      // 具体删除某一次订阅
      if (removeCb) {
        const index = this.events[eventName].findIndex(event => event.fn === removeCb);
        index > -1 && this.events[eventName].splice(index, 1);
      }
      else {
        this.events[eventName] = [];
      }
    }
    else {
      // 清空全部订阅
      this.events = {};
    }
  },
  // 订阅一次
  once: function(eventName, cb) {
    this.on(eventName, cb, true);
  }
}
```

### 7、JavaScript小括号、中括号、大括号的多义性
* <b>小括号：</b>
  语义1，函数声明时参数表（形参）
  语义2，和一些语句联合使用以达到某些限定作用（if、for等）
  语义3，和new一起使用用来传值(实参)
  语义4，作为函数或对象方法的调用运算符(如果定义了参数也可与语义3一样传实参)
  语义5，强制表达式运算（常用有eval解析JSON和匿名函数自执行）

* <b>中括号：</b>
  语义1，声明数组
  语义2，取数组成员
  语义3，定义对象成员(可以不遵循标识符规则，可以以数字开头定义标识符)
  语义4，取对象成员

* <b>大括号：</b>
  语义1，组织复合语句,这是最常见的 (for, if)
  语义2，对象直接量声明(赋值对象）
  语义3，声明函数或函数直接量赋值
  语义4，结构化异常处理的语法符号（try...catch语句)

疑惑点：
```
function() {} ()
{}.construtor
以上代码会报错。原因是js'语句优先'在作怪，即{}被理解成复合语句块(语义1)而不是对象直接量(语义2)或声明函数(语义3)的语义。

因此：
function(){}()，大括号被理解成复合语句，自然前面的function()声明函数的语法不完整导致语法分析期出错。
{}.constructor，大括号被理解成复合语句，大括号后面是点运算符，点运算符前没有合理的对象自然也报错。

解决：
(function(){})()，(function(){});//强制其理解为函数(语义3)，“函数()”表示执行该函数，即声明后立即执行了。
({}).constructor //({})强制把大括号理解成对象直接量(语义2)，“对象.xx”表示获取对象的成员，自然后面的点运算符可以正常执行了。  
```
<font color=red>扩展考点：</font>
1、函数提升，如果加了小括号，还会提升吗？
答：不能。小括号进行强制表达式运算，函数表达式是不会提升的。

### 8、typeof 和 instanceof 有什么区别及使用场景？
  typeof：对【原始数据类型】，除了null都可以使用typeof显示正确的类型。typeof null === 'object'，js历史遗留bug。对引用数据类型，除函数外，都会显示 ‘object’
  instanceof：基于原型链查询，能够找到正确的构造方法。但对基本数据类型无法作出判断。解决方式如下：
  ```
  class PrimitiveNumber {
    <!-- 在执行 instanceof 运算时，会自动执行下面静态方法 -->
    static [Symbol.hasInstance](instance) {
      return typeof instance === 'number'
    }
  }
  console.log(111 instanceof PrimitiveNumber);  true
  ```
  <b>那如何自己实现 instanceof 方法？</b> 
  核心：沿着原型链一直向上找
  ```
  function dataType(data, type) {
    // 对于基本数据类型，直接返回 false。因为 instance 判断不了原始数据类型（Number,String,Boolean）
    if (typeof data !== 'object' || typeof data === null) return false;
    // 获取数据的原型对象
    let proto = Object.getPrototypeOf(data);
    while(proto) {
      // 找到相同的原型对象
      if (proto === type.prototype) return true;
      proto = Object.getPrototypeOf(proto);
      // 查找到尽头，也没有找到
      if (proto === null) return false;
    }
  } 
  ```

### 9、HTTP 状态码
* 2开头表示成功的请求
  + 200 表示OK，正常返回信息
  + 201 表示请求成功且服务器创建了新的资源
  + 202 表示服务器已经接受了请求，但还未处理
* 3开头表示重定向
  + 301 表示永久重定向，请求的网页已经永久移动到新位置
  + 302 表示临时重定向
  + 304 表示自从上一次请求以来，页面的内容没有改变过
* 4开头表示客户端错误
  + 400 1、语义有误，当前请求无法被服务器理解 2、请求参数有误
  + 401 表示请求未授权，用户未登录
  + 402 该状态码是为了将来可能的需求而预留的
  + 403 表示禁止访问
  + 404 表示请求的资源不存在，一般是路径写错了
  + 500 表示最常见的服务器错误
  + 503 表示服务器暂时无法处理请求
  
### 10、带副作用的数组方法有哪些？
* push, pop, unshift, shift, splice
* sort, reverse, fill

### 11、http 请求头和响应头中都有哪些字段？哪些字段与页面缓存信息有关？
  <img src="https://images2015.cnblogs.com/blog/667706/201612/667706-20161205162518897-1265527411.png">

  【仅仅列举常见字段】
  <font size=5 color=red>request header:</font>
  + Accept : 指定客户端能够接收的内容类型，内容类型中的先后次序表示客户端接收的先后次序。(application/json, text/javascript, */*)
  + Accept-Encoding : 指定客户端浏览器可以支持的web服务器返回内容压缩编码类型。
  + 
  + Connection: 表示是否需要持久连接。
  + Content-Type : 显示此HTTP请求提交的内容类型。一般只有post提交时才需要设置该属性
  > 重要：浏览器通常使用MIME类型（而不是文件扩展名）来确定如何处理URL
  ```
  一般Content-Type语法结构:
  media-type
  资源或数据的 MIME type;
      +
  charset
  字符编码标准;
      +
  boundary
  对于多部分实体，boundary 是必需的

  MIME语法：
  通用结构: type/subtype
  {
    独立类型: [
      text/plain
      text/html
      image/jpeg
      image/png
      audio/mpeg
      audio/ogg
      audio/*
      video/mp4
      application/*
      application/json
      application/javascript
      ...
    ]
    Multipart 类型: [
      multipart/form-data
      multipart/byteranges
    ]
  }

  charset=utf-8

  实际运用如下，POST请求，一个是上传表单数据，一个是上文文件
  有关Content-Type属性值可以如下两种编码类型：
  (1) “application/x-www-form-urlencoded”： 
  表单数据向服务器提交时所采用的编码类型，默认的缺省值就是“application/x-www-form-urlencoded”。 

  (2) “multipart/form-data;boundary=something”： 
  在文件上载时，所使用的编码类型应当是“multipart/form-data”，它既可以发送文本数据，也支持二进制数据上载。
  对于多部分实体，boundary指令是必需的
  ```
  + Content-Length: 请求头的长度。
  + Cookie: 浏览器端cookie。
  + Host: 客户端地址
  + Origin: 目标地址
  + Referer: 一个URL地址，表示请求是从哪个页面url发出的
  + User-Agent: 客户端信息
  + x－Requested-With: 是否为同步请求 ，如果为XMLHttpRequest，则为 Ajax 异步请求。如果为null则为传统同步请求
  
  <font size=5 color=red>response header:</font>
  Access-Control-Allow与跨域有关
  + Access-Control-Allow-Headers: 首部字段用于预检请求的响应。正式请求是返回空
  + Access-Control-Allow-Methods: (GET, OPTIONS, HEAD, PUT, POST)
  + Access-Control-Allow-Origin: 控制该资源可以被其他外域访问 （* 表示任意外域）
  + Access-Control-Max-Age: 表明该响应的有效时间。在有效时间内，浏览器无须为同一请求再次发起预检请求
  + Content-Length: 响应体的长度
  + Cache-Control: 告诉所有的缓存机制是否可以缓存及哪种类型
  + Expires: 本次响应过期的日期和时间
  + Last-Modified: 请求资源的最后修改时间
  + Content-Type: 返回内容的类型（application/json;）
  + Set-Cookie：设置Http Cookie

### 12、浏览器缓存、HTTP缓存（强缓存、协商缓存），浏览器缓存和CDN的关系
> CDN: Content Delivery Network，即内容分发网络

对于（图片，css，js）等不经常发生变化的文件，将他们存储起来，对客户端而言是优化y哦那个户浏览体验的方法。
<b>文件缓存多久？一般是由<font color=red size=5>服务器</font>进行设置的</b>
> HTTP 响应头中 Expires 和 Cache-Control 就是完成这个事情的（就是通常指的“强缓存”）
* Expires: 本次响应过期的日期和时间
  ```
  Expires: Sun, 16 Oct 2016 05:43:02 GMT。（服务器绝对时间）
  告诉浏览器在 Sun, 16 Oct 2016 05:43:02 GMT 之前不要去服务器获取该文件了
  ```
* Cache-Control: 告诉所有的缓存机制是否可以缓存及哪种类型
  ```
  Cache-Control: max-age: 600 （浏览器相对时间）
  告诉客户端，以客户端相对时间，文件可以缓存10分钟
  ```
如果两个字段同时设置，则以 Cache-Control 为标准

<b>进阶知识:</b>
> 有个文件可能时不时会更新，需要客户端能时不时过来访问下这个文件是否过期。如果没过期，服务器就不会返回数据，而是告诉客户端你的缓存还没有过期（304）。然后浏览器使用自己的缓存来显示，这个叫做<font size=4 color=blue><b >协商缓存</b></font>。

实现过程：
* 1、客户端访问资源数据时，服务端在返回数据同时返回了<font color=red>Last-Modifed</font>:Wed, 07 Aug 2013 15:32:18 GMT，告诉客户端你获取的文件最后修改时间是Wed, 07 Aug 2013 15:32:18 GMT。客户端将文件放入缓存中，同时记录文件最后修改时间
* 2、第二次访问的时候（假设没有设置Expires和Cache-Control），客户端把服务器之前告诉的文件最后修改时间加在Request Header中 <font color=red>If-Modify-since</font>: Wed, 07 Aug 2013 15:32:18 GMT
* 3、服务器根据 Request Header 中 If-Modify-since，与文件最后修改时间进行比较。如果没修改返回304，否则返回200，并带上资源内容

【协商缓存】另一种实现方案：
打标签（Tag）<font color=red>ETag/ If-None-Match</font>，实现过程同Last-Modifed/If-Modify-since

<b>题外话：各种刷页面请求数据时表现的不同点？</b>
假设客户端第一次请求数据内容时，服务端返回了 cache-control: max-age:600，Last_Modify: Wed, 10 Aug 2013 15:32:18 GMT 字段。
* 直接浏览器url回车健一敲，浏览器以最少的请求来获取网页的数据，根据 Cache-Control 文件缓存时间没有过，直接从缓存中获取文件
* 按下F5或刷新按钮，浏览器会在请求中附加必要的缓存协商，带上 Last_Modify_since 检测下文件是否已经修改
* Ctrl + F5，删除本地缓存文件，去服务端请求完整数据

### 13、浏览器加载和渲染html、js、css的顺序
